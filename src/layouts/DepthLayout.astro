---
import "@fontsource-variable/inter";
import "@fontsource-variable/jetbrains-mono";
import "@fontsource-variable/space-grotesk";
import "@fontsource/rubik-mono-one";
import { ViewTransitions } from "astro:transitions";
import AnimatedLines from "@/components/AnimatedLines.astro";
import BaseHead from "@/components/BaseHead.astro";
import SkipLink from "@/components/SkipLink.astro";
import ThemeProvider from "@/components/ThemeProvider.astro";
import ThemeToggle from "@/components/ThemeToggle.astro";
import { siteConfig } from "@/site-config";
import type { SiteMeta } from "@/types";

interface Props {
	meta: SiteMeta;
	sectionCount?: number;
}

const {
	meta: { articleDate, description = siteConfig.description, ogImage, title },
	sectionCount = 4,
} = Astro.props;

// Generate section indicator buttons
const sections = Array.from({ length: sectionCount }, (_, i) => i);
---

<html class="scroll-smooth" lang={siteConfig.lang}>
	<head>
		<BaseHead articleDate={articleDate} description={description} ogImage={ogImage} title={title} />
		<ViewTransitions />
	</head>
	<body
		class="relative h-dvh overflow-hidden bg-bgColorInverse p-4 text-sm font-light leading-[2rem] sm:p-8 sm:text-base sm:leading-[2rem]"
	>
		<div class="noise"></div>
		<ThemeProvider />
		<AnimatedLines />
		<SkipLink />
		<ThemeToggle />
		<main x-data id="main" class="h-full origin-center tracking-wider">
			<div id="scroll-container" class="scroll-container rounded-2xl bg-bgColor">
				<!-- Section indicators -->
				<div id="section-indicators" class="section-indicators">
					{
						sections.map((i) => (
							<button
								data-section={i}
								class:list={["indicator", { active: i === 0 }]}
								aria-label={`Go to section ${i + 1}`}
							/>
						))
					}
				</div>

				<!-- Sections wrapper - linear scroll -->
				<div id="sections-wrapper" class="sections-wrapper">
					<slot />
				</div>
			</div>
		</main>
	</body>
</html>

<style is:global>
	[x-cloak] {
		display: none !important;
	}

	/* Scroll container - simple overflow scroll */
	.scroll-container {
		position: relative;
		width: 100%;
		height: 100%;
		overflow: hidden;
	}

	.sections-wrapper {
		width: 100%;
		height: 100%;
		overflow-y: auto;
		scroll-behavior: smooth;
		scrollbar-width: thin;
		scrollbar-color: hsl(var(--border-divider) / 0.3) transparent;
	}

	.sections-wrapper::-webkit-scrollbar {
		width: 8px;
	}

	.sections-wrapper::-webkit-scrollbar-track {
		background: transparent;
	}

	.sections-wrapper::-webkit-scrollbar-thumb {
		background-color: hsl(var(--border-divider) / 0.3);
		border-radius: 4px;
	}

	/* Sections stack vertically */
	.depth-section {
		min-height: 100%;
		display: flex;
		align-items: flex-start;
		justify-content: flex-start;
	}

	/* Section inner - no longer needs overflow, parent scrolls */
	.depth-section-inner {
		width: 100%;
		min-height: 100%;
	}

	/* Section indicators - Vintage VU Meter Style */
	.section-indicators {
		position: absolute;
		right: 1rem;
		bottom: 1rem;
		display: flex;
		flex-direction: column;
		gap: 0;
		z-index: 100;
		/* Inverse background - light on dark, dark on light */
		background: hsl(var(--theme-bg-inverse) / 0.95);
		backdrop-filter: blur(8px);
		padding: 6px 4px;
		border: 1px solid hsl(var(--border-divider) / 0.4);
		border-radius: 8px;
		/* Subtle inset shadow for depth */
		box-shadow:
			inset 1px 1px 3px rgba(0, 0, 0, 0.15),
			inset -1px -1px 2px rgba(255, 255, 255, 0.03),
			0 1px 3px rgba(0, 0, 0, 0.15);
	}

	@media (min-width: 640px) {
		.section-indicators {
			right: 1rem;
			bottom: 1rem;
			padding: 8px 6px;
		}
	}

	.indicator {
		/* LED segment shape - horizontal bar for vertical layout */
		width: 16px;
		height: 6px;
		border-radius: 3px;
		background: hsl(var(--border-divider) / 0.15);
		cursor: pointer;
		transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
		position: relative;
		margin: 4px 0;
		/* Subtle border for definition */
		border: 1px solid hsl(var(--border-divider) / 0.1);
		/* Base chromatic shadow - very subtle */
		box-shadow: 0 0 2px rgba(0, 0, 0, 0.1);
		filter: invert(1);
	}

	@media (min-width: 640px) {
		.indicator {
			width: 24px;
			height: 8px;
			border-radius: 4px;
			margin: 5px 0;
		}
	}

	/* Inner glow element for LED effect */
	.indicator::before {
		content: "";
		position: absolute;
		inset: 1px;
		border-radius: 2px;
		background: transparent;
		transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
	}

	/* Scanline overlay */
	.indicator::after {
		content: "";
		position: absolute;
		inset: 0;
		background: repeating-linear-gradient(
			0deg,
			transparent 0px,
			transparent 1px,
			rgba(0, 0, 0, 0.15) 1px,
			rgba(0, 0, 0, 0.15) 2px
		);
		border-radius: 3px;
		pointer-events: none;
		opacity: 0.5;
	}

	@media (min-width: 640px) {
		.indicator::before {
			border-radius: 3px;
		}
		.indicator::after {
			border-radius: 4px;
		}
	}

	.indicator:hover {
		background: hsl(var(--border-divider) / 0.35);
		/* Chromatic aberration on hover - horizontal offset */
		box-shadow:
			-1px 0 0 rgba(255, 50, 80, 0.4),
			1px 0 0 rgba(0, 255, 255, 0.4),
			0 0 8px hsl(var(--border-divider) / 0.2);
		transform: scaleX(1.1);
	}

	.indicator:hover::before {
		background: linear-gradient(
			90deg,
			rgba(255, 50, 80, 0.1) 0%,
			hsl(var(--border-divider) / 0.2) 50%,
			rgba(0, 255, 255, 0.1) 100%
		);
	}

	.indicator.active {
		background: linear-gradient(
			90deg,
			rgba(255, 50, 80, 0.7) 0%,
			rgba(255, 100, 150, 0.9) 30%,
			rgba(0, 255, 255, 0.7) 100%
		);
		border-color: rgba(255, 255, 255, 0.2);
		/* Strong chromatic aberration glow - horizontal */
		box-shadow:
			-2px 0 0 rgba(255, 50, 80, 0.8),
			2px 0 0 rgba(0, 255, 255, 0.8),
			-4px 0 6px rgba(255, 50, 80, 0.4),
			4px 0 6px rgba(0, 255, 255, 0.4),
			0 0 12px rgba(255, 100, 200, 0.5),
			0 0 20px rgba(255, 100, 200, 0.2);
		animation: led-pulse 2s ease-in-out infinite;
		filter: invert(0);
	}

	.indicator.active::before {
		background: linear-gradient(
			90deg,
			rgba(255, 200, 220, 0.4) 0%,
			rgba(255, 255, 255, 0.6) 50%,
			rgba(200, 255, 255, 0.4) 100%
		);
	}

	/* Passed sections stay off - same as inactive */
	.indicator.passed {
		background: hsl(var(--border-divider) / 0.15);
		box-shadow: 0 0 2px rgba(0, 0, 0, 0.1);
	}

	.indicator.passed::before {
		background: transparent;
	}

	/* LED pulse animation */
	@keyframes led-pulse {
		0%,
		100% {
			box-shadow:
				-2px 0 0 rgba(255, 50, 80, 0.8),
				2px 0 0 rgba(0, 255, 255, 0.8),
				-4px 0 6px rgba(255, 50, 80, 0.4),
				4px 0 6px rgba(0, 255, 255, 0.4),
				0 0 12px rgba(255, 100, 200, 0.5),
				0 0 20px rgba(255, 100, 200, 0.2);
		}
		50% {
			box-shadow:
				-2px 0 0 rgba(255, 50, 80, 0.9),
				2px 0 0 rgba(0, 255, 255, 0.9),
				-5px 0 8px rgba(255, 50, 80, 0.5),
				5px 0 8px rgba(0, 255, 255, 0.5),
				0 0 16px rgba(255, 100, 200, 0.6),
				0 0 28px rgba(255, 100, 200, 0.3);
		}
	}

	/* Light bulb flicker animation on switch */
	.indicator.flickering {
		animation: led-flicker 0.4s ease-out forwards;
	}

	@keyframes led-flicker {
		0% {
			opacity: 0.3;
			filter: brightness(0.5);
		}
		10% {
			opacity: 1;
			filter: brightness(1.5);
		}
		20% {
			opacity: 0.4;
			filter: brightness(0.6);
		}
		30% {
			opacity: 1;
			filter: brightness(1.3);
		}
		40% {
			opacity: 0.6;
			filter: brightness(0.8);
		}
		50% {
			opacity: 1;
			filter: brightness(1.4);
		}
		60% {
			opacity: 0.8;
			filter: brightness(0.9);
		}
		70% {
			opacity: 1;
			filter: brightness(1.2);
		}
		85% {
			opacity: 0.95;
			filter: brightness(1.05);
		}
		100% {
			opacity: 1;
			filter: brightness(1);
		}
	}
</style>

<script>
	class LinearNavigator {
		private container!: HTMLElement;
		private wrapper!: HTMLElement;
		private sections!: HTMLElement[];
		private indicators!: HTMLElement[];
		private currentIndex = 0;
		private visitedSections = new Set<number>();

		constructor() {
			const container = document.getElementById("scroll-container");
			const wrapper = document.getElementById("sections-wrapper");
			if (!container || !wrapper) return;

			this.container = container;
			this.wrapper = wrapper;
			this.sections = Array.from(document.querySelectorAll(".depth-section"));
			this.indicators = Array.from(document.querySelectorAll(".indicator"));

			if (this.sections.length === 0) return;

			this.init();
		}

		private init() {
			// Set up IntersectionObserver to track visible section
			const observer = new IntersectionObserver(
				(entries) => {
					entries.forEach((entry) => {
						if (entry.isIntersecting && entry.intersectionRatio >= 0.5) {
							const index = this.sections.indexOf(entry.target as HTMLElement);
							if (index !== -1 && index !== this.currentIndex) {
								this.updateCurrentSection(index);
							}
						}
					});
				},
				{
					root: this.wrapper,
					threshold: 0.5,
				}
			);

			this.sections.forEach((section) => observer.observe(section));

			// Handle initial hash
			const hash = window.location.hash.slice(1);
			if (hash) {
				const targetSection = this.sections.find((s) => s.id === hash);
				if (targetSection) {
					targetSection.scrollIntoView();
					const index = this.sections.indexOf(targetSection);
					this.updateCurrentSection(index);
				}
			} else {
				// Trigger initial section
				this.updateCurrentSection(0);
			}

			// Indicator clicks
			this.indicators.forEach((indicator, i) => {
				indicator.addEventListener("click", () => {
					this.sections[i]?.scrollIntoView({ behavior: "smooth" });
				});
			});

			console.log("ðŸŽ¯ Linear Navigator initialized with", this.sections.length, "sections");
		}

		private updateCurrentSection(index: number) {
			this.currentIndex = index;

			// Update URL hash
			const section = this.sections[index];
			if (section?.id) {
				history.replaceState(null, "", `#${section.id}`);
			} else {
				history.replaceState(null, "", window.location.pathname);
			}

			// Update indicators
			this.indicators.forEach((indicator, i) => {
				indicator.classList.remove("active", "passed", "flickering");
				if (i === index) {
					indicator.classList.add("active");
					// Add flicker effect
					void indicator.offsetWidth;
					indicator.classList.add("flickering");
					setTimeout(() => indicator.classList.remove("flickering"), 400);
				} else if (i < index) {
					indicator.classList.add("passed");
				}
			});

			// Dispatch section-enter event for Word animations
			const isFirstVisit = !this.visitedSections.has(index);
			this.visitedSections.add(index);
			document.dispatchEvent(
				new CustomEvent("section-enter", {
					detail: { index, isFirstVisit },
				})
			);
		}
	}

	function initNavigator() {
		new LinearNavigator();
	}

	// Initialize on page load
	document.addEventListener("DOMContentLoaded", initNavigator);
	document.addEventListener("astro:page-load", initNavigator);
</script>
