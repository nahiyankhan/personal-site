---
// Component for animated background lines with random opacity changes
---

<div id="animated-lines" class="pointer-events-none fixed inset-0 z-0"></div>

<script>
	// Audio reactivity state
	let audioIntensity = 0;
	let audioBass = 0;

	function initAnimatedLines() {
		const container = document.getElementById("animated-lines");
		if (!container) return;

		// Responsive line height: 16px on mobile, 32px on desktop
		const lineHeight = window.innerWidth >= 640 ? 32 : 16;
		const lineThickness = 1; // Thickness of the line in pixels
		const totalLines = Math.ceil(window.innerHeight / lineHeight) + 1;

		// Clear existing lines on re-init
		container.innerHTML = "";

		// Create line elements
		const lines: HTMLElement[] = [];
		for (let i = 0; i < totalLines; i++) {
			const line = document.createElement("div");
			line.className = "animated-line";
			line.style.position = "absolute";
			line.style.left = "0";
			line.style.right = "0";
			line.style.height = `${lineThickness}px`;
			line.style.top = `${i * lineHeight}px`;
			line.style.backgroundColor = `hsl(var(--border-divider) / 1)`;
			line.style.transition = "none";
			line.style.opacity = "0.15";

			// Randomly apply visual effects (subtle)
			const rand = Math.random();

			// 25% chance: chromatic aberration (will be increased when music plays)
			if (rand < 0.25) {
				line.style.filter =
					"drop-shadow(1px 0 0 rgba(255, 0, 0, 0.5)) drop-shadow(-1px 0 0 rgba(0, 255, 255, 0.5))";
			}

			container.appendChild(line);
			lines.push(line);
		}

		// Function to update chromatic effects based on music
		function updateChromaticEffects() {
			// When music is playing with intensity, apply chromatic aberration to more lines
			const musicThreshold = 0.2;
			if (audioIntensity > musicThreshold) {
				lines.forEach((line, index) => {
					// Increase chromatic aberration coverage based on audio intensity
					// From 25% baseline to up to 90% when music is intense
					const chromaticChance = 0.25 + audioIntensity * 0.65;
					const shouldHaveEffect = (index * 0.1 + audioIntensity) % 1.0 < chromaticChance;

					if (shouldHaveEffect) {
						// Amplify the effect strength based on audio (especially bass)
						// Enhanced multipliers for more pronounced effect
						const baseOffset = 1 + Math.floor(audioIntensity * 5);
						const bassBoost = audioBass > 0.5 ? Math.floor(audioBass * 4) : 0;
						const offset = baseOffset + bassBoost;
						const alpha = 0.6 + audioIntensity * 0.4;

						// Add slight random offset variation for more dynamic effect
						const randomVariation = Math.random() * 0.5;
						const finalOffset = offset + randomVariation;

						line.style.filter = `drop-shadow(${finalOffset}px 0 0 rgba(255, 0, 0, ${alpha})) drop-shadow(-${finalOffset}px 0 0 rgba(0, 255, 255, ${alpha}))`;

						// Add subtle glow on high intensity
						if (audioIntensity > 0.7) {
							line.style.filter += ` drop-shadow(0 0 ${audioIntensity * 3}px rgba(255, 0, 255, 0.3))`;
						}
					} else if (!line.style.filter.includes("drop-shadow")) {
						line.style.filter = "none";
					}
				});
			} else if (audioIntensity < 0.05) {
				// Reset to original state when music intensity is very low
				lines.forEach((line, index) => {
					const rand = (index * 0.73) % 1.0; // Deterministic pseudo-random
					if (rand < 0.25) {
						line.style.filter =
							"drop-shadow(1px 0 0 rgba(255, 0, 0, 0.5)) drop-shadow(-1px 0 0 rgba(0, 255, 255, 0.5))";
					} else {
						line.style.filter = "none";
					}
				});
			}
		}

		// Update chromatic effects continuously
		function updateLoop() {
			updateChromaticEffects();
			requestAnimationFrame(updateLoop);
		}
		updateLoop();

		// Randomly animate lines
		function animateLine(line: HTMLElement) {
			const randomDelay = Math.random() * 5000; // 0-5 seconds

			setTimeout(() => {
				// Random opacity: minimum 0.09, up to 0.6
				const opacitySteps = [0.09, 0.15, 0.3, 0.45, 0.6];
				const targetOpacity = opacitySteps[Math.floor(Math.random() * opacitySteps.length)];
				line.style.opacity = targetOpacity.toString();

				// Schedule next animation
				animateLine(line);
			}, randomDelay);
		}

		// Start animating random subset of lines
		const linesToAnimate = Math.floor(totalLines * 0.3); // Animate 30% of lines
		const shuffledLines = [...lines].sort(() => Math.random() - 0.5);

		for (let i = 0; i < linesToAnimate; i++) {
			animateLine(shuffledLines[i]);
		}

		// Handle window resize
		let resizeTimeout: NodeJS.Timeout;
		window.addEventListener("resize", () => {
			clearTimeout(resizeTimeout);
			resizeTimeout = setTimeout(() => {
				initAnimatedLines();
			}, 250);
		});
	}

	// Listen for audio data from music visualizer
	document.addEventListener("visualizer-colors", (event: any) => {
		const { audioLevels, isPlaying } = event.detail || {};
		if (audioLevels && isPlaying) {
			audioIntensity = audioLevels.intensity || 0;
			audioBass = audioLevels.bass || 0;
		} else {
			// Smoothly decay to zero when music stops
			audioIntensity *= 0.95;
			audioBass *= 0.95;
		}
	});

	// Initialize on load
	document.addEventListener("DOMContentLoaded", initAnimatedLines);

	// Re-initialize on theme change (if needed)
	document.addEventListener("astro:after-swap", initAnimatedLines);
</script>
