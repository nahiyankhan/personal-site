---
import Word from "@/components/Word.astro";
import { Icon } from "astro-icon/components";
---

<div class="flex flex-col items-start justify-center">
	<div
		id="intro-logo"
		class="logo-hidden relative overflow-hidden px-4 pb-4 pt-8 sm:px-8 sm:pb-8 sm:pt-8"
		data-logo-scale
	>
		<!-- NAHIYAN - 7 letters -->
		<Word letters={["n", "a", "h", "i", "y", "a", "n"]} />
		<!-- KHAN - 4 letters, aligned under NAHI -->
		<div class="mt-1">
			<Word letters={["k", "h", "a", "n"]} startIndex={7} />
		</div>
	</div>
	<div class="relative ml-4 h-12 w-12 rounded-full sm:ml-8 sm:h-16 sm:w-16">
		<a
			class="relative flex h-full w-full items-center justify-center rounded-full border bg-bgColor transition-all [&::after]:absolute [&::after]:h-12 [&::after]:w-12 [&::after]:origin-center [&::after]:rounded-full [&::after]:border [&::after]:border-transparent [&::after]:duration-300 [&::after]:content-[''] hover:[&::after]:scale-75 hover:[&::after]:border-divider dark:hover:[&::after]:border-divider [&::after]:sm:h-16 [&::after]:sm:w-16"
			type="button"
			x-data
			@click="$store.theme.toggleMode()"
		>
			<Icon
				aria-hidden="true"
				class="h-5 w-5 transition-all duration-300 dark:hidden sm:h-7 sm:w-7"
				focusable="false"
				name="solar:moon-bold-duotone"
			/>
			<Icon
				aria-hidden="true"
				class="hidden h-5 w-5 transition-all duration-300 dark:block sm:h-7 sm:w-7"
				focusable="false"
				name="solar:sun-bold-duotone"
			/>
		</a>
	</div>
</div>

<script>
	import { calculateLetterSize, applyLetterSize, debounce } from "@/utils/letterSizing";

	const LETTERS_COUNT = 7; // NAHIYAN (longest row)

	function updateLogoSize() {
		const logoElement = document.getElementById("intro-logo");
		if (!logoElement) return;

		const size = calculateLetterSize(LETTERS_COUNT);
		applyLetterSize("intro-logo", size);

		// Remove hidden class after sizing is applied
		logoElement.classList.remove("logo-hidden");
	}

	let canvas: HTMLCanvasElement | null = null;
	let gl: WebGLRenderingContext | null = null;
	let program: WebGLProgram | null = null;
	let texture: WebGLTexture | null = null;
	let animationId: number | null = null;
	let startTime = Date.now();
	let glInitialized = false;

	// Audio reactivity state
	let audioIntensity = 0;
	let audioBass = 0;

	const vertexShaderSource = `
		attribute vec2 position;
		void main() {
			gl_Position = vec4(position, 0.0, 1.0);
		}
	`;

	const fragmentShaderSource = `
		precision mediump float;
		uniform sampler2D src;
		uniform vec2 resolution;
		uniform vec2 offset;
		uniform float time;
		uniform float audioIntensity;
		uniform float audioBass;
		uniform float isDarkMode;

		float nn(float y, float t) {
			float n = (
				sin(y * 0.07 + t * 8.0 + sin(y * 0.5 + t * 10.0)) +
				sin(y * 0.7 + t * 2.0 + sin(y * 0.3 + t * 8.0)) * 0.7 +
				sin(y * 1.1 + t * 2.8) * 0.4
			);
			n += sin(y * 124.0 + t * 100.7) * sin(y * 877.0 - t * 38.8) * 0.3;
			return n;
		}

		void main() {
			vec2 uv = gl_FragCoord.xy / resolution;
			uv.y = 1.0 - uv.y;

			vec2 uvr = uv, uvg = uv, uvb = uv;

			float t = mod(time, 30.0);

			float fps = 10.0 + audioIntensity * 5.0;
			float tLaggy = floor(t * fps) / fps;

			float musicMultiplier = 1.0 + audioIntensity * 4.0;
			float amp = (10.0 / resolution.x) * musicMultiplier;

			float glitchSpeed = 1.0 + audioIntensity * 2.0;
			float glitchTrigger = sin(tLaggy * 1.3 * glitchSpeed) * sin(tLaggy * 2.7 * glitchSpeed) * sin(tLaggy * 4.1 * glitchSpeed);

			float threshold = 0.65 - audioIntensity * 0.35;
			float burstIntensity = smoothstep(threshold, 1.0, abs(glitchTrigger));

			float bassBoost = audioBass * 0.5;
			burstIntensity = min(1.0, burstIntensity + bassBoost);

			float glitchThreshold = 1.0 - audioIntensity * 0.5;
			if (burstIntensity > 0.0 && abs(nn(uv.y, tLaggy)) > glitchThreshold) {
				uvr.x += nn(uv.y, tLaggy) * amp * burstIntensity;
				uvg.x += nn(uv.y, tLaggy + 10.0) * amp * burstIntensity;
				uvb.x += nn(uv.y, tLaggy + 20.0) * amp * burstIntensity;
			}

			vec4 cr = texture2D(src, uvr);
			vec4 cg = texture2D(src, uvg);
			vec4 cb = texture2D(src, uvb);

			float combinedAlpha = smoothstep(0.0, 1.0, cr.a + cg.a + cb.a);

			if (isDarkMode > 0.5) {
				gl_FragColor = vec4(cr.r, cg.g, cb.b, combinedAlpha);
			} else {
				vec4 center = texture2D(src, uv);
				float allAligned = min(min(cr.a, cg.a), cb.a);
				vec3 rgbFringes = vec3(cr.a, cg.a, cb.a);
				vec3 finalColor = mix(rgbFringes, center.rgb, allAligned);
				gl_FragColor = vec4(finalColor, combinedAlpha);
			}
		}
	`;

	function createShader(gl: WebGLRenderingContext, type: number, source: string) {
		const shader = gl.createShader(type);
		if (!shader) return null;
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error("Shader compile error:", gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
			return null;
		}
		return shader;
	}

	function initGL() {
		const logoElement = document.getElementById("intro-logo");
		if (!logoElement) return;

		// Clean up existing canvas
		if (canvas) {
			canvas.remove();
			if (animationId) cancelAnimationFrame(animationId);
		}

		// Get all final letter SVGs
		const letterSvgs = logoElement.querySelectorAll(".letter-final svg");
		if (!letterSvgs.length) return;

		// Calculate combined bounding box of all letter SVGs
		const logoRect = logoElement.getBoundingClientRect();
		let minLeft = Infinity,
			minTop = Infinity,
			maxRight = -Infinity,
			maxBottom = -Infinity;

		letterSvgs.forEach((svg) => {
			const rect = svg.getBoundingClientRect();
			minLeft = Math.min(minLeft, rect.left);
			minTop = Math.min(minTop, rect.top);
			maxRight = Math.max(maxRight, rect.right);
			maxBottom = Math.max(maxBottom, rect.bottom);
		});

		const combinedWidth = maxRight - minLeft;
		const combinedHeight = maxBottom - minTop;

		// Add extra width for RGB shift effect
		const extraWidth = combinedWidth * 0.4;
		const canvasWidth = combinedWidth + extraWidth;

		// Create canvas
		canvas = document.createElement("canvas");
		canvas.style.position = "absolute";
		canvas.style.pointerEvents = "none";
		canvas.style.zIndex = "10";

		const svgOffsetLeft = minLeft - logoRect.left;
		const svgOffsetTop = minTop - logoRect.top;

		canvas.style.left = `${svgOffsetLeft - extraWidth / 2}px`;
		canvas.style.top = `${svgOffsetTop}px`;
		canvas.style.width = `${canvasWidth}px`;
		canvas.style.height = `${combinedHeight}px`;

		canvas.width = canvasWidth;
		canvas.height = combinedHeight;

		logoElement.appendChild(canvas);

		// Initialize WebGL
		gl = canvas.getContext("webgl", { alpha: true, premultipliedAlpha: false });
		if (!gl) {
			console.error("WebGL not supported");
			return;
		}

		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
		const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
		if (!vertexShader || !fragmentShader) return;

		program = gl.createProgram();
		if (!program) return;
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			console.error("Program link error:", gl.getProgramInfoLog(program));
			return;
		}

		gl.useProgram(program);

		const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
		const buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

		const positionLocation = gl.getAttribLocation(program, "position");
		gl.enableVertexAttribArray(positionLocation);
		gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

		// Create texture from letter SVGs
		const tempCanvas = document.createElement("canvas");
		tempCanvas.width = canvasWidth;
		tempCanvas.height = combinedHeight;
		const ctx = tempCanvas.getContext("2d");

		if (!ctx) {
			console.error("Could not get 2D context");
			return;
		}

		const textColor = getComputedStyle(document.documentElement).getPropertyValue("--theme-text");
		const actualColor = textColor ? `hsl(${textColor})` : getComputedStyle(letterSvgs[0]).color;
		ctx.fillStyle = actualColor;

		// Draw each letter SVG
		letterSvgs.forEach((svg) => {
			const svgRect = svg.getBoundingClientRect();
			const svgEl = svg as SVGSVGElement;
			const viewBox = svgEl.viewBox.baseVal;
			const hasViewBox = viewBox.width > 0 && viewBox.height > 0;

			if (hasViewBox) {
				ctx.save();

				const offsetX = svgRect.left - minLeft;
				const offsetY = svgRect.top - minTop;

				const scaleX = svgRect.width / viewBox.width;
				const scaleY = svgRect.height / viewBox.height;

				ctx.translate(extraWidth / 2 + offsetX - viewBox.x * scaleX, offsetY - viewBox.y * scaleY);
				ctx.scale(scaleX, scaleY);

				const paths = svg.querySelectorAll("path");
				paths.forEach((path) => {
					const d = path.getAttribute("d");
					if (d) {
						const path2d = new Path2D(d);
						ctx.fill(path2d);
					}
				});

				ctx.restore();
			}

			// Hide original SVG (WebGL canvas takes over)
			(svg as HTMLElement).style.opacity = "0";
		});

		// Also hide block SVGs
		const blockSvgs = logoElement.querySelectorAll(".letter-block svg");
		blockSvgs.forEach((svg) => {
			(svg as HTMLElement).style.opacity = "0";
		});

		if (!gl || !program) return;

		texture = gl.createTexture();
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tempCanvas);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

		glInitialized = true;
		startTime = Date.now();
		animate();
	}

	function animate() {
		if (!gl || !program || !canvas || !texture) return;

		const time = (Date.now() - startTime) / 1000;

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture);

		gl.viewport(0, 0, canvas.width, canvas.height);
		gl.clearColor(0, 0, 0, 0);
		gl.clear(gl.COLOR_BUFFER_BIT);

		const srcLocation = gl.getUniformLocation(program, "src");
		const resolutionLocation = gl.getUniformLocation(program, "resolution");
		const timeLocation = gl.getUniformLocation(program, "time");
		const offsetLocation = gl.getUniformLocation(program, "offset");
		const audioIntensityLocation = gl.getUniformLocation(program, "audioIntensity");
		const audioBassLocation = gl.getUniformLocation(program, "audioBass");
		const isDarkModeLocation = gl.getUniformLocation(program, "isDarkMode");

		const isDarkMode = document.documentElement.getAttribute("data-theme") === "dark" ? 1.0 : 0.0;

		gl.uniform1i(srcLocation, 0);
		gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
		gl.uniform1f(timeLocation, time);
		gl.uniform2f(offsetLocation, 0, 0);
		gl.uniform1f(audioIntensityLocation, audioIntensity);
		gl.uniform1f(audioBassLocation, audioBass);
		gl.uniform1f(isDarkModeLocation, isDarkMode);

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

		animationId = requestAnimationFrame(animate);
	}

	const handleResize = debounce(() => {
		updateLogoSize();
		// Delay GL init to allow CSS to update
		setTimeout(initGL, 100);
	}, 150);

	// Listen for audio data from music visualizer
	document.addEventListener("visualizer-colors", (event: any) => {
		const { audioLevels, isPlaying } = event.detail || {};
		if (audioLevels && isPlaying) {
			audioIntensity = audioLevels.intensity || 0;
			audioBass = audioLevels.bass || 0;
		} else {
			audioIntensity *= 0.95;
			audioBass *= 0.95;
		}
	});

	// Initialize on load - wait for letter animations to complete
	function initAfterAnimation() {
		updateLogoSize();
		// Wait for letter reveal animation to complete before initializing WebGL
		// 11 letters * 60ms delay + 400ms animation + 200ms initial delay = ~1.3s
		setTimeout(initGL, 1500);
	}

	// Run sizing immediately since the script is at the end of the component
	// This prevents the size jump from CSS defaults to JS-calculated values
	updateLogoSize();

	// Also run on DOMContentLoaded as a fallback
	document.addEventListener("DOMContentLoaded", initAfterAnimation);

	document.addEventListener("theme-change", () => {
		setTimeout(() => {
			updateLogoSize();
			initGL();
		}, 50);
	});

	window.addEventListener("resize", handleResize);

	document.addEventListener("astro:after-swap", initAfterAnimation);

	document.addEventListener("astro:before-preparation", () => {
		if (animationId) cancelAnimationFrame(animationId);
		if (canvas) canvas.remove();
		window.removeEventListener("resize", handleResize);
	});
</script>

<style>
	#intro-logo {
		position: relative;
		--letter-height: 48px;
		--letter-width: 55px;
	}

	@media (min-width: 640px) {
		#intro-logo {
			--letter-height: 64px;
			--letter-width: 73px;
		}
	}

	/* Hide until JS calculates correct size to prevent size jump */
	#intro-logo.logo-hidden {
		visibility: hidden;
	}
</style>
