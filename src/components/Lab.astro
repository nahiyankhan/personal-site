---
import { Image } from "astro:assets";
import LabTitle from "@/assets/lab.svg?raw";
import musicVizImage from "@/assets/music-viz.png";
import Subtitle from "./Subtitle.astro";
---

<div>
	<div class="relative flex flex-col items-end px-4 py-4 sm:px-8 sm:py-8">
		<div id="lab-logo" class="relative [&>svg]:w-full" data-logo-scale>
			<Fragment set:html={LabTitle} />
		</div>
		<div class="relative inline-flex w-[fit-content]">
			<div class="baseline-on-grid text-sm">a.k.a tinker town and where things break.</div>
		</div>
	</div>

	<div class="grid px-4 pb-16 sm:px-8 sm:pb-0">
		<Subtitle title="current-experiments" />

		<div class="mb-4 grid grid-cols-1 gap-4 sm:mb-8 sm:grid-cols-4 sm:gap-8">
			<div class="space-y-4">
				<a
					href="/prototypes/music-viz"
					class="border-current/10 hover:border-current/30 block overflow-hidden rounded-lg border transition-all"
					transition:name="music-viz-preview"
				>
					<Image src={musicVizImage} alt="Music Visualizer Preview" class="h-auto w-full" />
				</a>
				<div class="flex flex-col">
					<a
						href="/prototypes/music-viz"
						class="baseline-on-grid !mb-0 inline-block text-sm underline decoration-dotted underline-offset-4 hover:decoration-solid"
					>
						music visualizer
					</a>
					<p class="baseline-on-grid text-sm opacity-70">
						audio-reactive animations. from the portfolio editing floor.
					</p>
				</div>
			</div>
		</div>
	</div>
</div>

<script>
	// Logo scaling system for Lab - increments in baseline units, max 3 units
	const LOGO_ASPECT_RATIO = 1149 / 331; // ~3.5:1
	const isMobile = window.innerWidth < 640;
	const GRID_UNIT = isMobile ? 16 : 32; // Responsive baseline unit
	const HORIZONTAL_PADDING = isMobile ? 32 : 64; // p-4 on mobile, p-8 on desktop
	const MIN_UNITS = 2; // minimum
	const MAX_UNITS = 3; // maximum

	function calculateLogoSize(): number {
		const viewportWidth = window.innerWidth;
		let units = MIN_UNITS;

		while (units < MAX_UNITS) {
			const nextUnits = units + 1;
			const nextHeight = nextUnits * GRID_UNIT;
			const nextWidth = nextHeight * LOGO_ASPECT_RATIO;
			const nextTotalWidth = nextWidth + HORIZONTAL_PADDING;

			if (nextTotalWidth > viewportWidth) {
				break;
			}

			units = nextUnits;
		}

		return units * GRID_UNIT;
	}

	function updateLogoSize() {
		const logoElement = document.getElementById("lab-logo");
		if (!logoElement) return;

		const svg = logoElement.querySelector("svg");
		if (!svg) return;

		const height = calculateLogoSize();
		const units = height / GRID_UNIT;
		const width = height * LOGO_ASPECT_RATIO;
		const totalWidth = width + HORIZONTAL_PADDING;

		svg.style.height = `${height}px`;

		console.log("ðŸ§ª Lab Logo Scaling:", {
			viewportWidth: window.innerWidth,
			logoHeight: `${height}px (${units} Ã— 32px)`,
			logoWidth: `${Math.round(width)}px`,
			totalWidth: `${Math.round(totalWidth)}px`,
			maxAllowed: `${MAX_UNITS * GRID_UNIT}px`,
		});
	}

	let canvas: HTMLCanvasElement | null = null;
	let gl: WebGLRenderingContext | null = null;
	let program: WebGLProgram | null = null;
	let texture: WebGLTexture | null = null;
	let animationId: number | null = null;
	let startTime = Date.now();

	// Audio reactivity state
	let audioIntensity = 0;
	let audioBass = 0;

	const vertexShaderSource = `
		attribute vec2 position;
		void main() {
			gl_Position = vec4(position, 0.0, 1.0);
		}
	`;

	const fragmentShaderSource = `
		precision mediump float;
		uniform sampler2D src;
		uniform vec2 resolution;
		uniform vec2 offset;
		uniform float time;
		uniform float audioIntensity;
		uniform float audioBass;

		float nn(float y, float t) {
			float n = (
				sin(y * 0.07 + t * 8.0 + sin(y * 0.5 + t * 10.0)) +
				sin(y * 0.7 + t * 2.0 + sin(y * 0.3 + t * 8.0)) * 0.7 +
				sin(y * 1.1 + t * 2.8) * 0.4
			);
			n += sin(y * 124.0 + t * 100.7) * sin(y * 877.0 - t * 38.8) * 0.3;
			return n;
		}

		void main() {
			vec2 uv = gl_FragCoord.xy / resolution;
			// Flip Y coordinate for WebGL
			uv.y = 1.0 - uv.y;

			vec2 uvr = uv, uvg = uv, uvb = uv;

			float t = mod(time, 30.0);

			// Quantize time for laggy/stuttering effect - faster when music plays
			float fps = 10.0 + audioIntensity * 5.0;
			float tLaggy = floor(t * fps) / fps;

			// Amplify amplitude based on audio (2x to 5x multiplier when music plays)
			float musicMultiplier = 1.0 + audioIntensity * 4.0;
			float amp = (10.0 / resolution.x) * musicMultiplier;

			// Create sporadic glitch bursts with gaps - more frequent with music
			float glitchSpeed = 1.0 + audioIntensity * 2.0;
			float glitchTrigger = sin(tLaggy * 1.3 * glitchSpeed) * sin(tLaggy * 2.7 * glitchSpeed) * sin(tLaggy * 4.1 * glitchSpeed);

			// Lower threshold when music plays (0.65 -> 0.3), more glitches
			float threshold = 0.65 - audioIntensity * 0.35;
			float burstIntensity = smoothstep(threshold, 1.0, abs(glitchTrigger));

			// Add bass-reactive extra glitching
			float bassBoost = audioBass * 0.5;
			burstIntensity = min(1.0, burstIntensity + bassBoost);

			// Scanline-style shifts (per-row) - more likely with music
			float glitchThreshold = 1.0 - audioIntensity * 0.5;
			if (burstIntensity > 0.0 && abs(nn(uv.y, tLaggy)) > glitchThreshold) {
				uvr.x += nn(uv.y, tLaggy) * amp * burstIntensity;
				uvg.x += nn(uv.y, tLaggy + 10.0) * amp * burstIntensity;
				uvb.x += nn(uv.y, tLaggy + 20.0) * amp * burstIntensity;
			}

			vec4 cr = texture2D(src, uvr);
			vec4 cg = texture2D(src, uvg);
			vec4 cb = texture2D(src, uvb);

			gl_FragColor = vec4(cr.r, cg.g, cb.b, smoothstep(0.0, 1.0, cr.a + cg.a + cb.a));
		}
	`;

	function createShader(gl: WebGLRenderingContext, type: number, source: string) {
		const shader = gl.createShader(type);
		if (!shader) return null;
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error("Shader compile error:", gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
			return null;
		}
		return shader;
	}

	function initGL() {
		const logoElement = document.getElementById("lab-logo");
		if (!logoElement) return;

		// Clean up existing canvas
		if (canvas) {
			canvas.remove();
			if (animationId) cancelAnimationFrame(animationId);
		}

		// Get SVG dimensions first
		const svg = logoElement.querySelector("svg");
		if (!svg) return;

		const svgRect = svg.getBoundingClientRect();

		// Add extra width for RGB shift effect (20% on each side)
		const extraWidth = svgRect.width * 0.4; // 20% on each side
		const canvasWidth = svgRect.width + extraWidth;

		// Create canvas with extra width
		canvas = document.createElement("canvas");
		canvas.style.position = "absolute";
		canvas.style.pointerEvents = "none";

		// Position canvas to align with SVG, but offset left to center it
		const logoRect = logoElement.getBoundingClientRect();
		const svgOffsetLeft = svgRect.left - logoRect.left;
		const svgOffsetTop = svgRect.top - logoRect.top;

		canvas.style.left = `${svgOffsetLeft - extraWidth / 2}px`;
		canvas.style.top = `${svgOffsetTop}px`;
		canvas.style.width = `${canvasWidth}px`;
		canvas.style.height = `${svgRect.height}px`;

		canvas.width = canvasWidth;
		canvas.height = svgRect.height;

		logoElement.appendChild(canvas);

		// Initialize WebGL
		gl = canvas.getContext("webgl", { alpha: true, premultipliedAlpha: false });
		if (!gl) {
			console.error("WebGL not supported");
			return;
		}

		// Enable blending for transparency
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		// Create shaders
		const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
		const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
		if (!vertexShader || !fragmentShader) return;

		// Create program
		program = gl.createProgram();
		if (!program) return;
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			console.error("Program link error:", gl.getProgramInfoLog(program));
			return;
		}

		gl.useProgram(program);

		// Set up geometry
		const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
		const buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

		const positionLocation = gl.getAttribLocation(program, "position");
		gl.enableVertexAttribArray(positionLocation);
		gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

		// Create texture from SVG by drawing paths directly to canvas
		if (svg) {
			// Create a temporary 2D canvas with extra width for RGB shift
			const tempCanvas = document.createElement("canvas");
			tempCanvas.width = canvasWidth;
			tempCanvas.height = svgRect.height;
			const ctx = tempCanvas.getContext("2d");

			if (!ctx) {
				console.error("Could not get 2D context");
				return;
			}

			// Get the actual computed color
			const textColor = getComputedStyle(document.documentElement).getPropertyValue("--theme-text");
			const actualColor = textColor ? `hsl(${textColor})` : getComputedStyle(svg).color;

			// Get SVG viewBox to calculate proper scaling
			const viewBox = svg.viewBox.baseVal;
			const hasViewBox = viewBox.width > 0 && viewBox.height > 0;

			if (hasViewBox) {
				const scaleX = svgRect.width / viewBox.width;
				const scaleY = svgRect.height / viewBox.height;

				// Apply transformation and offset to center the SVG in the wider canvas
				ctx.translate(-viewBox.x * scaleX + extraWidth / 2, -viewBox.y * scaleY);
				ctx.scale(scaleX, scaleY);
			}

			// Manually draw the SVG paths to the canvas
			const paths = svg.querySelectorAll("path");
			ctx.fillStyle = actualColor;

			paths.forEach((path) => {
				const d = path.getAttribute("d");
				if (d) {
					const path2d = new Path2D(d);
					ctx.fill(path2d);
				}
			});

			if (!gl || !program) {
				console.error("WebGL context or program not available");
				return;
			}

			// Hide the original SVG since we'll render it via WebGL
			svg.style.opacity = "0";

			// Create WebGL texture from the 2D canvas
			texture = gl.createTexture();
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tempCanvas);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

			startTime = Date.now();
			animate();
		}
	}

	function animate() {
		if (!gl || !program || !canvas || !texture) {
			return;
		}

		const time = (Date.now() - startTime) / 1000;

		// Rebind texture for each frame
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, texture);

		gl.viewport(0, 0, canvas.width, canvas.height);
		gl.clearColor(0, 0, 0, 0);
		gl.clear(gl.COLOR_BUFFER_BIT);

		// Set uniforms
		const srcLocation = gl.getUniformLocation(program, "src");
		const resolutionLocation = gl.getUniformLocation(program, "resolution");
		const timeLocation = gl.getUniformLocation(program, "time");
		const offsetLocation = gl.getUniformLocation(program, "offset");
		const audioIntensityLocation = gl.getUniformLocation(program, "audioIntensity");
		const audioBassLocation = gl.getUniformLocation(program, "audioBass");

		gl.uniform1i(srcLocation, 0);
		gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
		gl.uniform1f(timeLocation, time);
		gl.uniform2f(offsetLocation, 0, 0);
		gl.uniform1f(audioIntensityLocation, audioIntensity);
		gl.uniform1f(audioBassLocation, audioBass);

		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

		animationId = requestAnimationFrame(animate);
	}

	// Debounce function for resize handler
	function debounce(func: Function, wait: number) {
		let timeout: ReturnType<typeof setTimeout> | null = null;
		return function executedFunction(...args: any[]) {
			const later = () => {
				timeout = null;
				func(...args);
			};
			if (timeout) clearTimeout(timeout);
			timeout = setTimeout(later, wait);
		};
	}

	// Resize handler
	const handleResize = debounce(() => {
		updateLogoSize();
		initGL();
	}, 150);

	// Listen for audio data from music visualizer
	document.addEventListener("visualizer-colors", (event: any) => {
		const { audioLevels, isPlaying } = event.detail || {};
		if (audioLevels && isPlaying) {
			audioIntensity = audioLevels.intensity || 0;
			audioBass = audioLevels.bass || 0;
		} else {
			// Smoothly decay to zero when music stops
			audioIntensity *= 0.95;
			audioBass *= 0.95;
		}
	});

	// Initialize on load
	document.addEventListener("DOMContentLoaded", () => {
		updateLogoSize();
		initGL();
	});

	// Reinitialize on theme change
	document.addEventListener("theme-change", () => {
		setTimeout(() => {
			updateLogoSize();
			initGL();
		}, 50);
	});

	// Handle window resize
	window.addEventListener("resize", handleResize);

	// Reinitialize after Astro transitions
	document.addEventListener("astro:after-swap", () => {
		updateLogoSize();
		initGL();
	});

	// Clean up on page unload
	document.addEventListener("astro:before-preparation", () => {
		if (animationId) cancelAnimationFrame(animationId);
		if (canvas) canvas.remove();
		window.removeEventListener("resize", handleResize);
	});
</script>
