---
import ASvg from "@/assets/letters/a.svg?raw";
import BSvg from "@/assets/letters/b.svg?raw";
import CSvg from "@/assets/letters/c.svg?raw";
import ESvg from "@/assets/letters/e.svg?raw";
import FSvg from "@/assets/letters/f.svg?raw";
import GSvg from "@/assets/letters/g.svg?raw";
import HSvg from "@/assets/letters/h.svg?raw";
import ISvg from "@/assets/letters/i.svg?raw";
import KSvg from "@/assets/letters/k.svg?raw";
import NSvg from "@/assets/letters/n.svg?raw";
import OSvg from "@/assets/letters/o.svg?raw";
import RSvg from "@/assets/letters/r.svg?raw";
import TSvg from "@/assets/letters/t.svg?raw";
import USvg from "@/assets/letters/u.svg?raw";
import YSvg from "@/assets/letters/y.svg?raw";

type LetterType =
	| "a"
	| "b"
	| "c"
	| "e"
	| "f"
	| "g"
	| "h"
	| "i"
	| "k"
	| "n"
	| "o"
	| "r"
	| "t"
	| "u"
	| "y";

interface Props {
	letters: LetterType[];
	startIndex?: number;
	wordId?: string;
}

const letterMap: Record<LetterType, string> = {
	a: ASvg,
	b: BSvg,
	c: CSvg,
	e: ESvg,
	f: FSvg,
	g: GSvg,
	h: HSvg,
	i: ISvg,
	k: KSvg,
	n: NSvg,
	o: OSvg,
	r: RSvg,
	t: TSvg,
	u: USvg,
	y: YSvg,
};

const { letters, startIndex = 0, wordId } = Astro.props;

// Intro (no wordId) starts hidden for reveal animation
// Other sections start visible
const isIntro = !wordId;
---

<div class="word-container" data-word-id={wordId}>
	{
		letters.map((letter, i) => (
			<div
				class:list={[
					"letter-box",
					wordId ? `letter-box-${wordId}` : "",
					{ "needs-reveal": isIntro },
				]}
				data-index={startIndex + i}
			>
				<Fragment set:html={letterMap[letter]} />
			</div>
		))
	}
</div>

<style>
	.word-container {
		display: flex;
		gap: 4px;
	}

	.letter-box {
		width: var(--letter-width, 55px);
		height: var(--letter-height, 48px);
		max-width: 218px;
		max-height: 192px;
		flex-shrink: 0;
		opacity: 1; /* Visible by default */
	}

	/* Intro letters start hidden until revealed */
	.letter-box.needs-reveal {
		opacity: 0;
	}

	.letter-box :global(svg) {
		width: 100%;
		height: 100%;
		display: block;
	}

	/* Full reveal animation - for intro first load */
	.letter-box.revealing {
		animation: glitchIn 0.8s steps(6, end) forwards;
	}

	/* Glitch in - laggy emergence */
	@keyframes glitchIn {
		0%,
		16% {
			opacity: 0;
			transform: translate(0, 0);
			filter: none;
		}
		17%,
		32% {
			opacity: 0.7;
			transform: translate(-3px, -1px);
			filter: drop-shadow(-5px 1px 0 #ff0000) drop-shadow(5px -1px 0 #00ffff);
		}
		33%,
		48% {
			opacity: 0;
			transform: translate(2px, 1px);
			filter: none;
		}
		49%,
		64% {
			opacity: 1;
			transform: translate(2px, -1px);
			filter: drop-shadow(4px 0 0 #ff0000) drop-shadow(-4px 0 0 #00ffff);
		}
		65%,
		80% {
			opacity: 1;
			transform: translate(-1px, 0);
			filter: drop-shadow(-2px 0 0 #ff0000) drop-shadow(2px 0 0 #00ffff);
		}
		81%,
		100% {
			opacity: 1;
			transform: translate(0, 0);
			filter: none;
		}
	}

	/* Glitch blink - intentionally laggy, heavy chromatic aberration */
	.letter-box.blinking {
		animation: glitchBlink 1.6s steps(16, end) forwards;
	}

	@keyframes glitchBlink {
		/* Holding... */
		0%,
		6% {
			opacity: 1;
			transform: translate(0, 0);
			filter: none;
		}
		/* Violent tear out */
		7%,
		9% {
			opacity: 0.6;
			transform: translate(-6px, 2px);
			filter: drop-shadow(-8px 3px 0 #ff0032) drop-shadow(8px -3px 0 #00ffff);
		}
		10%,
		15% {
			opacity: 0;
			transform: translate(4px, -2px);
			filter: none;
		}
		/* Long stuck frame - nothing */
		16%,
		28% {
			opacity: 0;
			transform: translate(0, 0);
			filter: none;
		}
		/* Trying to load... fails */
		29%,
		32% {
			opacity: 0.2;
			transform: translate(-8px, 4px);
			filter: drop-shadow(-10px 4px 0 #ff0032) drop-shadow(10px -4px 0 #00ffff);
		}
		33%,
		38% {
			opacity: 0;
			transform: translate(3px, -1px);
			filter: none;
		}
		/* Another stuck frame */
		39%,
		48% {
			opacity: 0;
			transform: translate(0, 0);
			filter: none;
		}
		/* Partial recovery - heavy aberration */
		49%,
		54% {
			opacity: 0.4;
			transform: translate(-5px, -3px);
			filter: drop-shadow(-12px 5px 0 #ff0032) drop-shadow(12px -5px 0 #00ffff);
		}
		55%,
		58% {
			opacity: 0.7;
			transform: translate(4px, 2px);
			filter: drop-shadow(8px -3px 0 #ff0032) drop-shadow(-8px 3px 0 #00ffff);
		}
		/* Drops again */
		59%,
		65% {
			opacity: 0;
			transform: translate(-2px, 1px);
			filter: none;
		}
		/* Fighting back */
		66%,
		72% {
			opacity: 0.5;
			transform: translate(-4px, -2px);
			filter: drop-shadow(-9px 4px 0 #ff0032) drop-shadow(9px -4px 0 #00ffff);
		}
		73%,
		76% {
			opacity: 0.8;
			transform: translate(3px, 1px);
			filter: drop-shadow(6px -2px 0 #ff0032) drop-shadow(-6px 2px 0 #00ffff);
		}
		/* Almost there - still aberrated */
		77%,
		85% {
			opacity: 1;
			transform: translate(-2px, 0);
			filter: drop-shadow(-4px 2px 0 #ff0032) drop-shadow(4px -2px 0 #00ffff);
		}
		/* Settle with lingering aberration */
		86%,
		92% {
			opacity: 1;
			transform: translate(0, 0);
			filter: drop-shadow(-2px 1px 0 rgba(255, 0, 50, 0.5)) drop-shadow(2px -1px 0 rgba(0, 255, 255, 0.5));
		}
		/* Finally clean */
		93%,
		100% {
			opacity: 1;
			transform: translate(0, 0);
			filter: none;
		}
	}
</style>

<script>
	function shuffleArray<T>(array: T[]): T[] {
		const shuffled = [...array];
		for (let i = shuffled.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
		}
		return shuffled;
	}

	// Full reveal animation - letters pop in one by one
	function revealWord(wordId?: string) {
		const selector = wordId ? `.letter-box-${wordId}` : ".letter-box:not([class*='letter-box-'])";
		const boxes = Array.from(document.querySelectorAll(selector));
		if (!boxes.length) return;

		const shuffled = shuffleArray(boxes);

		shuffled.forEach((box, i) => {
			const delay = 300 + i * 150 + Math.random() * 100;

			setTimeout(() => {
				box.classList.remove("needs-reveal");
				box.classList.add("revealing");
				// Clean up after animation
				setTimeout(() => box.classList.remove("revealing"), 800);
			}, delay);
		});

		console.log(`âœ¨ Revealing ${shuffled.length} letters for word: ${wordId || "intro"}`);
	}

	// Glitch blink - random letters do a quick glitch
	function blinkWord(wordId?: string) {
		const selector = wordId ? `.letter-box-${wordId}` : ".letter-box:not([class*='letter-box-'])";
		const boxes = Array.from(document.querySelectorAll(selector));
		if (!boxes.length) return;

		// Pick 2-4 random letters to blink
		const numToBlink = Math.floor(Math.random() * 3) + 2;
		const shuffled = shuffleArray(boxes).slice(0, numToBlink);

		shuffled.forEach((box) => {
			// Random delay for each blink
			const delay = Math.random() * 500;

			setTimeout(() => {
				box.classList.add("blinking");
				setTimeout(() => box.classList.remove("blinking"), 1600);
			}, delay);
		});
	}

	// Section index to wordId mapping
	const sectionWordMap: Record<number, string> = {
		1: "about",
		2: "forge",
		3: "contact",
	};

	// Track state
	let introRevealed = false;
	let lastAnimatedSection: number | null = null;

	// Listen for section-enter events
	document.addEventListener("section-enter", (e: any) => {
		const { index, isFirstVisit } = e.detail;

		// Don't re-animate if we're still on the same section
		if (index === lastAnimatedSection) return;
		lastAnimatedSection = index;

		// Section 0 (intro)
		if (index === 0) {
			if (!introRevealed && isFirstVisit) {
				// First time seeing intro - full reveal
				revealWord();
				introRevealed = true;
			} else {
				// Revisit - just blink
				blinkWord();
			}
			return;
		}

		// Other sections - always just blink (they're already visible)
		const wordId = sectionWordMap[index];
		if (wordId) {
			blinkWord(wordId);
		}
	});

	// Run intro animation on load
	function initIntro() {
		if (!introRevealed) {
			setTimeout(() => {
				if (!introRevealed) {
					revealWord();
					introRevealed = true;
					lastAnimatedSection = 0;
				}
			}, 200);
		}
	}

	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", initIntro);
	} else {
		initIntro();
	}

	// Reset on Astro page transitions
	document.addEventListener("astro:after-swap", () => {
		introRevealed = false;
		lastAnimatedSection = null;
		// Reset intro letters to hidden state
		document.querySelectorAll(".letter-box:not([class*='letter-box-'])").forEach((box) => {
			box.classList.add("needs-reveal");
			box.classList.remove("revealing", "blinking");
		});
	});

	// Ambient random blinks at random intervals
	function scheduleRandomBlink() {
		// Random interval between 0.8-2.5 seconds
		const delay = 800 + Math.random() * 1700;

		setTimeout(() => {
			// Only blink if intro has been revealed
			if (introRevealed) {
				// Get all visible letter boxes (not currently animating)
				const allBoxes = Array.from(
					document.querySelectorAll(".letter-box:not(.needs-reveal):not(.revealing):not(.blinking)")
				);

				if (allBoxes.length > 0) {
					// Pick 1-2 random letters to blink
					const numToBlink = Math.floor(Math.random() * 2) + 1;
					const shuffled = shuffleArray(allBoxes).slice(0, numToBlink);

					shuffled.forEach((box) => {
						box.classList.add("blinking");
						setTimeout(() => box.classList.remove("blinking"), 1600);
					});
				}
			}

			// Schedule next blink
			scheduleRandomBlink();
		}, delay);
	}

	// Start ambient blinks after intro reveal
	setTimeout(scheduleRandomBlink, 3000);
</script>
